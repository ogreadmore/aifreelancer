<script>
/* ============================================================
   AI FREELANCER CHAT WIDGET â€” OPTIMIZED VERSION (FORMATTING FIX)
   ------------------------------------------------------------
   Changes from previous:
     â€¢ Enhanced Markdown/HTML rendering with sanitization
     â€¢ Allows safe tags (a, strong, em, ul, li, etc.) to render properly
     â€¢ Strips risky/unwanted code; handles escaped HTML better
     â€¢ Keeps all prior optimizations (no storage, fresh starts, etc.)
============================================================ */

/* ---------- CONFIG ---------- */
const AF_CHAT_ENDPOINTS = [
  '/api/chat', // production (implement when ready)
  'https://aifreelancerchatbotvercelthing.vercel.app/api/chat' // fallback
];

// Optional config endpoint (ignored if fails)
const AF_CHAT_CONFIG_ENDPOINT = '/api/chat-config';

// Greeting + suggestion defaults (overridden if config loads)
const AF_CHAT_DEFAULT_CONFIG = {
  brand: 'AI Freelancer',
  greeting: "Hey! I'm the AI assistant for AI Freelancer. What can I help with today? ðŸ˜Š",
  suggestions: [
    "Pricing options",
    "Schedule a consultation",
    "What do you automate?"
  ],
  leadKeywords: [
    "price","pricing","quote","consult","consultation","demo","call","book","speak","talk","contact","estimate","schedule","meeting"
  ],
  schedulerLink: 'https://hello.aifreelancer.co/' // Your custom scheduler
};

/* ---------- STATE ---------- */
const AFChatState = {
  initialized: false,
  sending: false,
  history: [],      // {role:'user'|'assistant',content:'...'} â€” in-memory only, resets on close
  config: { ...AF_CHAT_DEFAULT_CONFIG }
};

/* ---------- DOM LOOKUPS ---------- */
const afEls = {
  launcher: document.getElementById('chatbot-launcher'),
  window: document.getElementById('chatbot-window'),
  closeBtn: document.getElementById('close-chatbot'),
  clearBtn: document.getElementById('clear-chatbot'),
  form: document.getElementById('chatbot-form'),
  input: document.getElementById('chatbot-input'),
  messages: document.getElementById('chatbot-messages'),
  contactForm: document.getElementById('contact-form'),
  thankYouModal: document.getElementById('thank-you-modal'),
  closeModalButton: document.getElementById('close-modal-button'),
  header: document.getElementById('header'),
  mobileMenuButton: document.getElementById('mobile-menu-button'),
  mobileMenu: document.getElementById('mobile-menu'),
  video: document.getElementById('intro-video'),
  videoOverlay: document.getElementById('video-overlay')
};

/* ---------- UTIL: safe gtag ---------- */
function afGtag(eventName, params={}) {
  if (typeof window.gtag === 'function') {
    window.gtag('event', eventName, params);
  }
}

/* ---------- UTIL: basic HTML escape ---------- */
function afEscape(str='') {
  return str
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;');
}

/* ---------- UTIL: linkify URLs in plain text ---------- */
function afLinkify(str='') {
  const escaped = afEscape(str);
  return escaped.replace(
    /(https?:\/\/[^\s<]+)/g,
    '<a href="$1" target="_blank" rel="noopener noreferrer" class="underline text-blue-600 break-all">$1</a>'
  );
}

/* ---------- UTIL: convert newlines to <br> ---------- */
function afNl2br(str='') {
  return str.replace(/\n/g,'<br>');
}

/* ---------- ENHANCED: Markdown to HTML with Sanitization ---------- */
function afMarkdownToHtml(md) {
  // Step 1: Convert Markdown to HTML
  let html = md
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>') // Bold
    .replace(/__(.+?)__/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>') // Italic
    .replace(/_(.+?)_/g, '<em>$1</em>')
    .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="underline text-blue-600">$1</a>') // Links
    .replace(/^# (.*$)/gm, '<h3 class="font-bold text-lg mt-2 mb-1">$1</h3>') // Headings
    .replace(/^## (.*$)/gm, '<h4 class="font-bold text-md mt-2 mb-1">$1</h4>')
    .replace(/^\s*[-*]\s+(.*$)/gm, '<li>$1</li>'); // Lists
  html = html.replace(/(?:<li>.*?<\/li>\s*)+/g, match => `<ul class="list-disc pl-5 my-1">${match}</ul>`);

  // Step 2: Fallback to linkify and nl2br for plain text parts
  html = afLinkify(html);
  html = afNl2br(html);

  // Step 3: Sanitize to allow only safe tags/attributes and prevent raw code display
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = html; // Parse as HTML

  const allowedTags = ['a', 'strong', 'em', 'ul', 'li', 'h3', 'h4', 'br', 'p'];
  const allowedAttributes = {
    'a': ['href', 'target', 'rel', 'class']
  };

  function sanitizeNode(node) {
    if (node.nodeType === 1) { // Element node
      const tag = node.tagName.toLowerCase();
      if (!allowedTags.includes(tag)) {
        // Replace disallowed tags with their text content
        return node.textContent;
      }
      // Remove disallowed attributes
      Array.from(node.attributes).forEach(attr => {
        if (!allowedAttributes[tag] || !allowedAttributes[tag].includes(attr.name)) {
          node.removeAttribute(attr.name);
        }
      });
      // Recurse on children
      Array.from(node.childNodes).forEach(child => {
        const sanitized = sanitizeNode(child);
        if (typeof sanitized === 'string') {
          node.replaceChild(document.createTextNode(sanitized), child);
        }
      });
    }
    return node;
  }

  sanitizeNode(tempDiv);
  return tempDiv.innerHTML;
}

/* ---------- UTIL: get relative timestamp ---------- */
function afGetTimestamp() {
  return 'Just now';
}

/* ---------- RENDER: bot message (with enhanced Markdown/HTML) ---------- */
function afAddBotMessage(text) {
  const timestamp = afGetTimestamp();
  const wrapper = document.createElement('div');
  wrapper.className = 'flex mb-4 justify-start';
  const bubble = document.createElement('div');
  bubble.className = 'p-3 max-w-xs chat-bubble-bot text-gray-700 af-chat-msg';
  bubble.innerHTML = afMarkdownToHtml(text) + `<div class="text-xs text-gray-400 mt-1 text-right">${timestamp}</div>`;
  wrapper.appendChild(bubble);
  afEls.messages.appendChild(wrapper);
  afScrollMessages();
}

/* ---------- RENDER: user message (text only, escaped) ---------- */
function afAddUserMessage(text) {
  const timestamp = afGetTimestamp();
  const wrapper = document.createElement('div');
  wrapper.className = 'flex mb-4 justify-end';
  const bubble = document.createElement('div');
  bubble.className = 'p-3 max-w-xs chat-bubble-user af-chat-msg text-white';
  bubble.innerHTML = afEscape(text) + `<div class="text-xs text-blue-200 mt-1 text-right">${timestamp}</div>`;
  wrapper.appendChild(bubble);
  afEls.messages.appendChild(wrapper);
  afScrollMessages();
}

/* ---------- RENDER: thinking indicator ---------- */
function afAddThinking() {
  const thinking = document.createElement('div');
  thinking.className = 'flex mb-4';
  thinking.innerHTML = `
    <div class="chat-bubble-bot p-3">
      <div class="flex items-center gap-1">
        <span class="thinking-dot"></span>
        <span class="thinking-dot"></span>
        <span class="thinking-dot"></span>
      </div>
      <p class="text-xs text-gray-500 mt-1">AI is thinking...</p>
    </div>`;
  afEls.messages.appendChild(thinking);
  afScrollMessages();
  return thinking;
}

/* ---------- RENDER: quick reply chips ---------- */
function afRenderChips() {
  const { suggestions=[] } = AFChatState.config;
  if (!suggestions.length) return;
  const chipRow = document.createElement('div');
  chipRow.className = 'flex flex-wrap gap-2 mb-4';
  suggestions.forEach(label => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'af-quick-chip px-3 py-1 rounded-full border text-sm hover:bg-gray-100 transition';
    btn.textContent = label;
    btn.addEventListener('click', () => {
      afEls.input.value = label;
      afSubmitMessage(); // auto-send on click
    });
    chipRow.appendChild(btn);
  });
  const wrapper = document.createElement('div');
  wrapper.className = 'flex justify-start mb-2';
  const bubble = document.createElement('div');
  bubble.className = 'chat-bubble-bot p-2 max-w-xs';
  bubble.appendChild(chipRow);
  wrapper.appendChild(bubble);
  afEls.messages.appendChild(wrapper);
  afScrollMessages();
}

/* ---------- RENDER: greeting (fresh every time) ---------- */
function afRenderGreeting() {
  const { greeting } = AFChatState.config;
  afEls.messages.innerHTML = '';
  afAddBotMessage(greeting);
  afRenderChips();
}

/* ---------- SCROLL ---------- */
function afScrollMessages() {
  afEls.messages.scrollTop = afEls.messages.scrollHeight;
}

/* ---------- CLEAR CHAT (resets to greeting) ---------- */
function afClearChat() {
  AFChatState.history = [];
  afRenderGreeting();
  afGtag('chat_clear', { event_category:'chat' });
}

/* ---------- LEAD DETECTION & HANDLING (no capture, direct link) ---------- */
function afDetectLeadIntent(text) {
  const kws = AFChatState.config.leadKeywords || [];
  const lower = text.toLowerCase();
  return kws.some(k => lower.includes(k));
}

function afHandleLeadIntent() {
  const link = AFChatState.config.schedulerLink;
  afAddBotMessage(`Great! Let's get that scheduled. Head over <a href="${link}" target="_blank" rel="noopener noreferrer" class="underline text-blue-600">here</a> to book a free consultation.`);
  afGtag('chat_lead_suggestion', { event_category:'chat' });
}

/* ---------- MESSAGE SUBMIT FLOW ---------- */
function afSubmitMessage() {
  if (AFChatState.sending) return;
  let userMessage = afEls.input.value.trim();
  if (!userMessage || userMessage.length > 500) { // Max length to prevent spam
    afEls.input.value = '';
    return;
  }
  afEls.input.value = '';
  afAddUserMessage(userMessage);

  AFChatState.history.push({ role:'user', content:userMessage });

  // Check for lead intent (handle directly, no capture)
  if (afDetectLeadIntent(userMessage)) {
    afHandleLeadIntent();
    return; // Skip AI call if it's a clear lead intent
  }

  const thinkingNode = afAddThinking();
  afSetSending(true);
  afSendToAI(userMessage, thinkingNode);
}

/* ---------- SEND TO AI (endpoint fallback, limited history) ---------- */
async function afSendToAI(userMessage, thinkingNode) {
  let lastErr;
  // Send only last ~10 messages to save tokens
  const payloadHistory = AFChatState.history.slice(-10);

  for (const url of AF_CHAT_ENDPOINTS) {
    try {
      const res = await fetch(url, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ message:userMessage, history:payloadHistory })
      });
      if (!res.ok) {
        console.warn('[AFChat] '+url+' â†’ '+res.status);
        lastErr = new Error('HTTP '+res.status);
        continue;
      }
      const data = await res.json();
      const botReply = data.reply ?? data.message ?? data.content ?? '[No reply received]';

      if (thinkingNode?.remove) thinkingNode.remove();
      afAddBotMessage(botReply);

      AFChatState.history.push({ role:'assistant', content:botReply });

      afSetSending(false);
      afGtag('chat_bot_reply', { event_category:'chat' });

      // Post-reply lead check (if not already handled)
      if (afDetectLeadIntent(botReply) || afDetectLeadIntent(userMessage)) {
        afHandleLeadIntent();
      }
      return;
    } catch (err) {
      console.warn('[AFChat] error calling', url, err);
      lastErr = err;
    }
  }

  // All failed
  if (thinkingNode?.remove) thinkingNode.remove();
  afAddBotMessage("Sorry, something went wrong. Try the contact form below or ask again!");
  afSetSending(false);
  console.error('[AFChat] all endpoints failed', lastErr);
}

/* ---------- SENDING STATE UI ---------- */
function afSetSending(isSending) {
  AFChatState.sending = isSending;
  const btn = afEls.form?.querySelector('button[type="submit"]');
  if (btn) {
    btn.disabled = isSending;
    btn.classList.toggle('opacity-50', isSending);
    btn.classList.toggle('cursor-not-allowed', isSending);
  }
}

/* ---------- INPUT KEY HANDLING ---------- */
if (afEls.input) {
  afEls.input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      afSubmitMessage();
    }
  });
}

/* ---------- FORM SUBMIT ---------- */
if (afEls.form) {
  afEls.form.addEventListener('submit', e => {
    e.preventDefault();
    afSubmitMessage();
  });
}

/* ---------- CHAT WINDOW TOGGLE (reset state on close) ---------- */
function afToggleChat(show) {
  const win = afEls.window;
  if (!win) return;
  if (show) {
    win.classList.remove('hidden');
    win.setAttribute('aria-hidden', 'false');
    requestAnimationFrame(() => {
      win.style.transform = 'scale(1)';
      win.style.opacity = '1';
      afEls.input.focus();
    });
    if (!AFChatState.initialized) {
      AFChatState.initialized = true;
      afRenderGreeting();
      afGtag('chat_open', { event_category:'chat' });
    }
  } else {
    win.style.transform = 'scale(0.95)';
    win.style.opacity = '0';
    setTimeout(() => {
      win.classList.add('hidden');
      win.setAttribute('aria-hidden', 'true');
      // Reset state on close (no persistence)
      AFChatState.history = [];
      AFChatState.initialized = false;
    }, 300);
    afGtag('chat_close', { event_category:'chat' });
  }
}
if (afEls.launcher) {
  afEls.launcher.addEventListener('click', () => {
    const isHidden = afEls.window.classList.contains('hidden');
    afToggleChat(isHidden);
  });
}
if (afEls.closeBtn) {
  afEls.closeBtn.addEventListener('click', () => afToggleChat(false));
}
if (afEls.clearBtn) {
  afEls.clearBtn.addEventListener('click', afClearChat);
}

/* ---------- LOAD REMOTE CONFIG (optional) ---------- */
async function afLoadRemoteConfig() {
  try {
    const res = await fetch(AF_CHAT_CONFIG_ENDPOINT, { method:'GET' });
    if (!res.ok) return;
    const data = await res.json();
    AFChatState.config = { ...AFChatState.config, ...data };
  } catch (_) {}
}

/* ---------- HEADER / MOBILE MENU / VIDEO (existing behaviors) ---------- */
(function afHeaderMobileEtc(){
  const { mobileMenuButton, mobileMenu, header, video, videoOverlay } = afEls;

  if (mobileMenuButton && mobileMenu) {
    mobileMenuButton.addEventListener('click', () => mobileMenu.classList.toggle('hidden'));
    document.querySelectorAll('#mobile-menu a').forEach(link => {
      link.addEventListener('click', () => mobileMenu.classList.add('hidden'));
    });
  }

  if (header) {
    window.addEventListener('scroll', () => {
      if (window.scrollY > 50) {
        header.classList.add('bg-white','backdrop-blur-sm','shadow-md');
      } else {
        header.classList.remove('bg-white','backdrop-blur-sm','shadow-md');
      }
    });
  }

  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function(e) {
      const target = document.querySelector(this.getAttribute('href'));
      if (!target) return;
      e.preventDefault();
      target.scrollIntoView({ behavior:'smooth' });
    });
  });

  if (video && videoOverlay) {
    videoOverlay.addEventListener('click', () => video.play());
    video.addEventListener('play', () => {
      videoOverlay.style.opacity='0';
      videoOverlay.style.pointerEvents='none';
      video.controls=true;
    });
    video.addEventListener('pause', () => {
      if (video.currentTime>0 && !video.ended) {
        videoOverlay.style.opacity='1';
        videoOverlay.style.pointerEvents='auto';
        video.controls=false;
      }
    });
    video.addEventListener('ended', () => {
      videoOverlay.style.opacity='1';
      videoOverlay.style.pointerEvents='auto';
      video.controls=false;
      video.currentTime=0;
    });
  }
})();

/* ---------- CONTACT FORM (existing AJAX submit + modal) ---------- */
(function afContactFormAjax(){
  const form = afEls.contactForm;
  const modal = afEls.thankYouModal;
  const closeBtn = afEls.closeModalButton;
  if (!form) return;

  function showModal() { modal?.classList.remove('hidden'); }
  function hideModal() { modal?.classList.add('hidden'); }

  form.addEventListener('submit', function(e) {
    e.preventDefault();
    const formData = new FormData(form);
    fetch(form.action, {
      method:'POST',
      body:formData,
      headers:{'Accept':'application/json'}
    }).then(response => {
      if (response.ok) {
        form.reset();
        showModal();
      } else {
        response.json().then(data => {
          if (Object.hasOwn(data, 'errors')) {
            alert(data.errors.map(error => error.message).join(', '));
          } else {
            alert('Sorry, there was a problem sending your message.');
          }
        });
      }
    }).catch(() => {
      alert('Sorry, there was a problem sending your message.');
    });
  });

  closeBtn?.addEventListener('click', hideModal);
  modal?.addEventListener('click', e => { if (e.target === modal) hideModal(); });
})();

/* ---------- INJECT MINOR STYLE TWEAKS (chips, wrap, Markdown) ---------- */
(function afInjectStyles(){
  const css = `
    .af-chat-msg { white-space:pre-line; word-break:break-word; overflow-wrap:anywhere; }
    .af-quick-chip { border:1px solid rgba(0,0,0,0.15); background:#fff; }
    .af-quick-chip:hover { background:#f3f4f6; }
    .chat-bubble-bot strong { font-weight: bold; color: #111827; }
    .chat-bubble-bot em { font-style: italic; color: #374151; }
    .chat-bubble-bot ul { list-style-type: disc; padding-left: 1.25rem; margin: 0.5rem 0; }
    .chat-bubble-bot h3 { font-size: 1.125rem; font-weight: 700; margin: 0.5rem 0; }
    .chat-bubble-bot a { word-break: break-all; }
  `;
  const tag = document.createElement('style');
  tag.setAttribute('data-afchat','');
  tag.textContent = css;
  document.head.appendChild(tag);
})();

/* ---------- INIT ---------- */
(async function afInit(){
  await afLoadRemoteConfig(); // optional override
  // Chat opens lazily on first click; greeting rendered fresh each time
})();
</script>
